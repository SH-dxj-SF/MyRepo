# 渲染页面：流览器工作原理

## 概述

等待资源加载时间和大部分情况下的浏览器单线程执行是影响 Web 性能的两大主要原因。

## 浏览器输入一个 URL 按下回车后发生了什么？

1. 域名解析（为拿到服务器 IP 地址）

   1. 缓存解析域名

      优先级为：浏览器缓存-->系统缓存-->路由器缓存，如果缓存中查找无果则查找系统的 hosts 文件；

   2. DNS（Domain Name System）解析域名

2. 浏览器与与服务器建立 TCP 连接（三次握手，默认 80 端口）。

3. 如果是 HTTPS 请求，还需要 TLS（传输层安全协议）来确认互相身份、要使用的加密算法、会话密钥（用于对称加密）

4. 浏览器发送 HTTP 请求（主要信息：请求方法、请求说明、请求附加的数据）。

5. 服务器解析请求并做出响应，返回结果给浏览器。

6. 浏览器拿到响应结果（网页请求一般为 HTML 文件），处理相应逻辑：解析文档资源渲染页面，也就是关键渲染路径（CRP）中所描述的事情。

7. TCP 连接关闭（四次握手）

## 关键渲染路径（Critical rendering path）

**关键渲染路径**是浏览器将 HTML，CSS 和 JavaScript 转换为屏幕上的像素所经历的步骤序列。优化关键渲染路径可提高渲染性能。关键渲染路径包含了 文档对象模型 (DOM)，CSS 对象模型 (CSSOM)，渲染树和布局。

- **解析 HTML，生成 DOM 树**

  每当解析过程中遇到外部资源链接时都会发起请求，不论是样式表（css）、脚本（js）还是嵌入的图片引用。有些请求会阻塞，意味着剩余 HTML 的解析会被暂停，直到引入的资源被处理完成。然后浏览器继续解析 HTML，发送请求、构造 DOM 直到文件结尾。

  DOM 构建是增量的

  节点数越多，CRP 中后续事件将花费的时间也就越长。

  关于 css、js 资源加载时的阻塞问题：

  - css 的加载不会阻塞 HTML 的解析，但是会阻塞页面渲染

  - css 的加载阻塞 js 的执行

  - js 的加载会阻塞 HTML 的解析和渲染：外部 js 脚本如果加上 defer 或者 async 则不会阻塞 HTML 的解析和渲染。defer 作用的脚本按照<script\>标签书写的前后顺序执行，async 作用的脚本则并行执行和书写顺序无关。

- **解析 CSS 生成 CSSOM 树**

  DOM 包含页面所有的内容，CSSOM 包含了页面所有的样式，也就是如何设置 DOM 样式的信息。它们二者相似，但又不同。DOM 构造是增量的，但 CSSOM 不是。

  CSS 是阻塞渲染的：浏览器阻塞渲染，直到它接受并处理了所有的 CSS。CSS 阻塞渲染是因为它的规则是可以被覆盖的，所以如果 CSSOM 没有完成是不能进行内容渲染的。

- **将 DOM 树和 CSSOM 树结合，生成渲染树（Render Tree）**

  渲染树包含了内容和样式：DOM 和 CSSOM 树组合成渲染树。为了构造渲染树，浏览器从 DOM 树根节点开始，检查每一个节点，并决定哪些 CSS 规则需要给添加。

  渲染树只包含可见内容，head 部分（通常）不含有可见信息，所以不会被包含在渲染树中。如果一个元素设置了 display: none 属性，那么它和它的子元素都不会出现在渲染树中。

- **Layout：根据生成的渲染树，计算渲染树元素（节点）的几何信息（位置、大小）**

  一旦渲染树生成，布局就成为了可能。布局取决于屏幕尺寸的大小，布局这个步骤决定了在页面上的什么地方以及如何去放置元素。确定元素的位置大小以及它们之间的关系。

  布局性能手 DOM 影响，节点数越多，布局需要的时间越长。

- **Painting：渲染树创建且布局完成，将像素绘制到屏幕上**

  根据渲染树和布局计算出的几何信息，得到节点的绝对像素，然后绘制到屏幕上。加载时，整个屏幕会被绘制出来，之后，只有受影响的区域会被重绘。

### 优化 CRP

通过优先加载某些资源、控制它们的加载顺序、缩小资源的体积来优化页面的加载速度。

性能提示包含：

- 最小化关键资源数量：通过延迟加载、异步加载或者完全剔除某些资源。
- 优化必要请求的数量和每个请求的文件大小。
- 优化关键资源加载顺序：优先下载关键资源，缩短关键路径的长度。

## CSS 图层

浏览器在渲染一个页面时，会将页面分为很多个图层（有大，有小），每一个图层上有一个或多个节点。在渲染 DOM 的时候，实际做的工作如下：

1. 获取 DOM 后分割为多个图层
2. 对每个图层的节点计算样式结果
3. 为每个节点生成图形和位置
4. 将每个节点绘制填充到图层位图中
5. 图层作为纹理上传到 GUI
6. 复合多个图层到页面上生成最终屏幕图像（图层重组）

**创建图层的条件：**

- 拥有 3D 或者透视变换的 CSS 属性（perspective、transform）
- 使用加速视频解码的<video\>节点
- 拥有 3D（WebGL）上下文或者加速的 2D 上下文的<canvas\>节点
- CSS3 动画的插件（例如 Flash）
- 拥有加速 CSS 过滤器的元素（transform：如 translateZ（0）、opacity、filter、will-change）

## 重绘（repaint）

一个元素的外观外观改变所触发的浏览器行为。例如 background-color、outline 的属性，这些不影响元素的布局，只影响元素的外观、风格，会造成 DOM 元素的重新渲染，这被称为重绘。

注意 ⚠️：重绘是以图层为单位的，如果某个图层中的某个元素需要重绘，那么整个图层都需要重绘。所以，将频繁重绘回流的 DOM 元素作为一个独立图层。但是原则上要尽量避免新建图层，因为图层过多会增加图层重组是的计算量。

## 回流（reflow、layout）

当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变，而需要计算它们在设备视口（viewport）内的确切位置和大小，那这个计算阶段就称之为布局也叫作回流（reflow）。

回流阶段主要是计算节点的几何信息（位置，大小），所以当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：

- 页面开始渲染的时候（无法避免的）
- 添加或删除可见的 DOM 元素
- 元素位置发生变化
- 元素尺寸发生变化（内外边距、边框大小、宽高等）
- 内容发生变化（文本变化、图片被另一个不同尺寸的图片替代）
- 浏览器窗口尺寸变化（因为节点的位置、大小是根据视口的大小来计算的）

注意 ⚠️：回流一定会触发重绘，但是重绘不一定触发回流。

display：none 会触发回流；visibility：hidden 只会触发重绘，因为没有发生位置变化

## 如何减少重绘和回流

- CSS

  1. transform 的 translate 代替 top、bottom、left、right
  2. opacity、visibility 代替 display 属性，前二者只会引起重绘
  3. 动画效果应用到绝对定位（absolute、fixed）元素上，将其脱离文档流，避免影响父元素和后续元素。这样只是一个重绘，避免回流。
  4. 频繁回流和重绘的节点新创建一个图层
  5. CSS3 硬件加速（GPU 加速）
  6. 避免使用 table 布局，可能小改动会引起整个 table 的重新布局
  7. **尽量**避免 box-shadow、border-radius 等耗性能的属性

  8. 样式书写顺序：

     1. 定位属性：position display float left top right bottom overflow clear z-index
     2. 自身属性：width height padding border margin background
     3. 文字样式：font-family font-size font-style font-weight font-variant color
     4. 文本属性：text-align vertical-align text-wrap text-transform text-indent text-decoration letter-spacing word-spacing white-space text-overflow
     5. css3 中新增属性：content box-shadow border-radius transform ...

- JavaScript

  1. 避免频繁操作样式：一次性重写 style 属性，或者将样式列表定义为 class 并一次性修改 class 属性。大多数现代浏览器已经优化
  2. 避免频繁操作 DOM：创建一个 documentFragment，在它上面操作完了再一次性插入到文档中。
  3. 避免频繁读取会引发回流和重绘的属性：如不可避免则使用变量缓存
