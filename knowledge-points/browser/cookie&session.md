# Cookie

Cookie 就是访问者在访问网站后留下的一个信息片段。用于个性化用户的体验，可能包含用户在访问网站时的参数或输入。用户可以自定义浏览器来接受、拒绝或删除 Cookie。

Cookie 可以在服务器端通过 HTTP 响应头 Set-Cookie 向客户端发送（设置、修改）；也可以通过 JavaScript，通过 document.cookie 设置、修改。

Cookie 会在浏览器向同一个服务器再次发起请求时携带发送到服务器。通常被用来告知服务器请求是否来自同一浏览器，比如保持用户登录状态。Cookie 使得无状态的 HTTP 协议记录稳定的状态信息成为了可能。

主要用于以下三个场景：

1. 会话状态管理（如用户状态、购物车记录或其他需要记录的信息）
2. 个性化设置（自定义用户设置、主题等等）
3. 浏览器行为跟踪（跟踪分析用户行为等）

# Session

Session 代表客户端和服务器一次会话（通讯）的过程。Session 对象存储着特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的信息将不会丢失，而是在整个用户会话中存在下去。当客户端关闭会话（一般是浏览器通过 cookie 存储 session id，所以这里关闭会话也就是关闭浏览器），或者 session 超时失效时会话结束。

# 它们之间有何不同

1. 作用范围不同：Cookie 存储在客户端（比如浏览器）；Session 存储在服务端。

2. 存取数据类型不同：Cookie 只能保存 ASCII；Session 可以存储任意类型（一般保存一些常用变量信息，如 userID 等）

3. 隐私策略不同：Cookie 存储在客户端，比较容易遭到不法获取；Session 存储在服务端，安全性相对高一些。

4. 存储大小不同：单个 Cookie 保存数据不超过 4KB；Session 的存储大小远超 Cookie（例如取决于 JVM 的内存）。

关于有效期：

客户端 Cookie 和服务端 Session 都可以设置自己的过期时间。

Cookie 不设置时间的情况下关闭浏览器时会被清除，设置了过期时间则到过期时间才清除。
Session 同样也可设置过期时间（默认 15 分钟即 900 秒）。

但是一般在使用 Session 的时候需要客户端通过 Cookie 存储 session id，通过客户端请求携带的 session id 查找 Session 列表中的会话。这个时候 Session 过期时间可能不一定是 Session 对象被服务端清除的时间，而是说这个 Session 失效的时间（取决于客户端 Cookie 保存的 session id 过期时间）。

# 它们之间有什么关联

我们知道，HTTP 协议是无状态的。所以浏览器也不知道到底是谁在和服务端打交道，这个时候就需要一个机制来告诉服务端，本次操作的是哪一个用户，该用户有没有登录之类的。这套机制就需要 Cookie 和 Session 来协作实现。

用户首次请求服务端时，服务端根据用户提交的相关信息，创建对应的 Session，请求返回时将该 Session 的 id（唯一标识）返回给浏览器。浏览器收到服务端返回的 SessionID 后，将其存储到 Cookie 中，同时会记录属于哪个域名。

当用户再次请求时，浏览器会查看域名下是否有 Cookie 信息，如果存在那么将 Cookie 信息携带在请求头中一并发送到服务端。服务端通过 SessionID 查找对应的 Session 对象，没有找到就说明未登录或者已经失效，如果找到则证明登录有效，可进行后续操作。
所以 SessionID 和连接 Cookie 和 Session 的一道桥梁。

# 如果浏览器 Cookie 被禁用了

用户可以自定义禁用 Cookie，如果 Cookie 被禁用了，这样一套机制怎么保证？

1. 通过请求参数携带：每一次请求中都携带 SessionID 参数（header），也可以是 post 方法的提交，也可以在请求的 url 后（查询参数）拼接上该信息。

2. Token 机制（可存储在 localStorage 中）：该机制一般多用于 App 客户端和服务端交互的模式，也可用于 Web 端做用户状态管理。Token 字面意思即“令牌”，是服务端生成的一个字符串，作为客户端进行请求的一个标识。类似于 Cookie 和 Session 协作的机制，第一次登录时服务端根据用户信息生成 Token，响应式将 Token 返回给客户端，后边再次请求时携带该 Token 信息请求即可，无需再次验证（除非 Token 已失效）。

# 分布式 Session 问题

互联网公司为了支撑大流量，后端往往需要多台服务器来支撑前端用户的请求。我们考虑这个场景，用户第一次在服务器 A 登录了，然后再次请求时是服务器 B 来处理，那么服务器 B 是不知道用户登录过的。这时候，一般有以下几种解决方案：

1. Nginx IP_hash 策略：服务端使用 Nginx 代理，每个请求按照 IP 的 hash 分配，这样达到同一个 IP 访问同一台服务器的效果。避免相同 IP 的请求分发到不同服务器的问题。

2. Session 复制：任何一台服务器上的 Session 发生变化（增删改），该节点会将该 Session 的内容序列化然后广播给其他所有节点同步。

3. Session 共享：服务端无状态化，将用户的 Session 等信息通过缓存中间件来统一管理，保证分发到每一台服务器的响应结果一致。
