# JavaScript 内存管理

简介：底层语言（比如 C）一般都有底层内存管理的接口 malloc()和 free()，但是 JS 是在创建变量（字符串、对象等）是自动分配内存，并在不使用它们时“自动”释放，释放的过程称为垃圾回收。这个“自动”是混乱的根源，是的，众多 JS（以及其他一些高级语言）开发者错误地认为它们无需关心内存管理。

注意 ⚠️：JS 同时是动态语言（还有 Php、Python…）,静态语言有 C、C++、Java…但是 JS、Java、C、C++同样都是高级语言

## 内存生命周期

不管什么语言，内存生命周期基本一致：

1. 分配你所需要的内存
2. 使用分配到的内存（读/写）
3. 不使用时将其释放/归还

所有语言第二部分都是明确的，第一部分和第三部分在底层语言中明确而在像 JS 这种高级语言中大多是隐含的。

### JS 的内存分配

#### 值的初始化

为了不让程序员费心分配内存，JS 在定义变量时就完成了内存分配。

```js
var n = 123; // 给数值变量分配内存
var s = 'string'; // 给字符串分配内存

var o = {
  a: 1,
  b: null,
}; // 给对象及其包含的值分配内存

// 给数组及其包含的值分配内存（就像对象一样）
var arr = [1, null, 'sss'];

// 给函数（可调用对象）分配内存
function f(a) {
  return a + 2;
}

// 函数表达式也能分配一个对象
someElement.addEventListener(
  'click',
  function () {
    someElement.style.backgroundColor = 'blue';
  },
  false
);
```

#### 通过函数调用分配内存

有些函数调用结果是分配对象内存：

```js
var d = new Date(); // 分配一个Date对象
var e = document.createElement('div'); // 分配一个DOM元素
```

有些方法分配新变量或者新对象：

```js
var s = 'string';
var s2 = s.substr(0, 3); // s2是一个新的字符串
// 因为字符串是不变量，
// JavaScript 可能决定不分配内存，
// 只是存储了 [0-3] 的范围。

var a = ['a', 'b'];
var a2 = ['b', 'c'];
var a3 = a.concat(a2); // ['a', 'b', 'b', 'c']
// 新数组有四个元素，是 a 连接 a2 的结果
```

### 使用值

实际上是对分配内存进行读取/写入操作，读/写可能是一个变量或者一个对象的属性，甚至传递参数给一个方法。

### 当内存不再需要使用时释放

大多数内存管理问题都在这个阶段。这里最艰巨的任务就是找到哪些“被分配的内存确实已经不再需要了”。它往往需要开发人员确定哪一块内存不再需要并且释放它。

高级语言解释器嵌入了“垃圾回收器”，它主要工作就是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过算法计算得出）

## 垃圾回收（GC，即 Garbage Collection）

垃圾回收只能有限制的解决一般的问题（因为正如上文所述，无法判定某块内存是否仍然需要），接下来会介绍 JS 回收算法以及其局限性。

### 引用

垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，如果一个对象有访问另一个对象的权限（隐式或显式），叫一个对象引用另一个对象。比如，一个 JS 对象具有对其原型的引用（隐）和对其属性的引用（显）。

注：此处“对象”概念不仅指 JS 对象，还包括函数作用域（或者全局词法作用域）

### 引用计数垃圾回收

这是最初的垃圾回收算法。此算法将“对象是否不再需要”简化定义为“对象有没有被其他对象引用到”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

```js
var o = {
  a: {
    b: 2,
  },
};
// 两个对象被创建，一个({b: 2})作为另一个({a: {b: 2}})的属性被引用，另一个被分配个变量 o
// 显然，没有一个可以被垃圾收集

var o2 = o; // 变量o2是第二个对“这个对象”的引用

o = 1; // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有

var oa = o2.a; // 引用“这个对象”的a属性
// 现在，“这个对象”有两个引用了，一个是o2，一个是oa

o2 = 'yo'; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
// 但是它的属性a的对象还在被oa引用，所以还不能回收

oa = null; // a属性的那个对象现在也是零引用了
// 它可以被垃圾回收了
```

#### 限制：无法处理循环引用场景

下面例子我们可以看到有两个对象互相引用，当函数调用后它们离开了函数作用域，此时它们已经无用了，本应被回收。但是由于它们各被对方引用了一次，该算法就认为它们不应被回收。

```js
function f() {
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return 'azerty';
}

f();
```

实例（IE6、7 使用计数回收机制），循环引用常造成内存泄漏

```js
var div;
window.onload = function () {
  div = document.getElementById('myDivElement');
  div.circularReference = div;
  div.lotsOfData = new Array(10000).join('*');
};
```

上述例子中 myDivElement 自身的 circularReference 属性引用了自身，如果该属性没有被显示置为 null 或者移除，那么引用计数垃圾回收器将总是且至少有一个引用，即使 DOM 树中将其删除了，该 DOM 元素还是保留在内存中。如果 DOM 元素上拥有大量数据（如上图中 lostOfData），它们占用的内存也将一直不会被释放，导致浏览器变得越来越卡顿。

### 标记-清除算法

该算法将“对象是否不再需要”简化定义为“对象是否可以获得”。

该算法将假定设置一个叫做根（root）对象（JavaScrip 中根为全局对象）。垃圾回收器定期从根开始，查找根引用的对象，然后递归查找这些对象中引用的对象。垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。

该算法优势在于 _“零引用对象”总是不可获得的，反之（不可获得对象总是“零引用对象”）不一定成立_ ，可参考“循环引用” 例子

循环引用不再是问题：因为一旦它们不能从根获得，那么就算它们被引用过也会被回收。

限制：所有无法从根获得的对象都将被垃圾回收器回收，尽管这是一个限制，但是实践中很少碰到似情况。

# JavaScript 内存泄漏（Memory Leak）

指程序中不再使用（需要）的内存，由于某种原因没有被合理地释放，仍然被不必要的占有。JS 中有自己的垃圾回收机制，可以判断哪些变量不再需要并将其清除。但是，当代码存在某些缺陷的时候，工程师和程序的想法就会产生分歧，你认为不需要的变量其实程序中还存在引用。这样导致程序运行过后没有合适地回收占用空间，导致内存占用越来越多，久而久之会是的程序性能不佳，甚至崩溃。

## 常见的内存泄漏

- 意外的全局变量

  非严格模式下，给一个未声明的变量赋值将会在全局对象（浏览器中为 window）上创建一个新变量。我们知道垃圾回收机制无法回收全局变量，所以会导致泄漏。

  解决方案：1.使用严格模式；2.不可避免时，使用完将其置为 nul 或者重新赋值。

- 被遗忘的定时器

  无用的定时器忘记清除（新手易犯的错误）。

- 被遗忘的事件监听

  无用的事件监听忘记清理（同样是新手易犯）

- DOM 引用

  保留了 DOM 节点的引用，即使从文档中移除了 DOM，内存中还是存在引用，没有被移除

  ```js
  var refA = document.getElementById('refA');
  document.body.removeChild(refA); // dom 移除了
  console.log('refA: ', refA); // 引用仍然存在，可以打印出整个 refA（DOM），没有被回收
  ```

  解决方案：变量置为 null，例如例子中的 refA = null;

- 闭包的错误（过度）使用

  闭包本身是没有错的。
