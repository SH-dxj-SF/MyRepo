# JS 线程

JavaScript 是单线程的，即 JS 代码只在一个线程上运行，也就是 JS 同时只执行一个任务。因为主要用于浏览器，JS 用途也就和用户交互，操作 DOM 之类相关，为了避免复杂度和冲突（比如：并行的代码一方在某个 DOM 中添加内容，另一方则删除该 DOM，这时不知道以谁为准），所以 JS 就设计成了单线程的。

虽然 JS 是单线程的，但是其宿主环境（浏览器、Node）是多线程的。浏览器有其他线程辅助 JS 线程的运行，如：

1. GUI 渲染线程
2. JS 引擎线程（主线程）
3. 定时器触发线程（setTimeout）
4. 浏览器事件线程（onClick）
5. HTTP 异步线程

   ......

其中 1、2、4 为常驻线程。

JS 主线程运行 JS 代码（不包括异步代码）

# JS 并发模型和事件循环

JavaScript 有一个基于**事件循环**的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。该模型和其他语言中的模型截然不同（如 C、Java）。

## 运行时概念

接下来的内容解释了这个理论模型。现代 JavaScript 引擎实现并着重优化了以下描述的这些语义。

可视化描述
![运行时环境](https://raw.githubusercontent.com/SH-dxj-SF/MyRepo/master/images/eventLoop.png)

栈：函数调用形成了一个由若干帧组成的栈

```js
function foo(b) {
  let a = 10;
  return a + b + 11;
}

function bar(x) {
  let y = 3;
  return foo(x * y);
}

console.log(bar(7)); // 42
```

1. 调用 bar 时，第一个帧被创建并压入栈中，帧中包含了 bar 的参数和局部变量。
2. 当 bar 调用 foo 时，第二个帧被创建并压入栈，放在第一个帧之上，帧中包含 foo 的参数和局部变量。
3. 当 foo 执行完毕返回时，第二个帧就被弹出栈（剩下 bar 函数的调用帧）。
4. 当 bar 也执行完毕并返回时，第一个帧也被弹出，此时栈被清空了。

堆：对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。

队列：一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。

在**事件循环**期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。正如前面所提到的，调用函数总是会为其创造一个新的栈帧。

函数的处理会一直进行到执行栈再次为空为止，然后事件循环将会处理队列中的下一个消息（如果还有的话）。

## 事件循环

之所以被称为事件循环，是因为它经常按类似如下的方式来实现

```js
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

queue.waitForMessage()会同步的等待消息到达（如果当前没有消息等待被处理）

“执行至完成”

每一个消息完整地执行后，其他消息才会被执行。

这为程序的分析提供了一些优秀的特性，包括：当一个函数执行时，它不会被抢占，只有在它运行完毕之后才会去运行任何其他的代码，才能修改这个函数操作的数据。这和 C 语言不同，例如，如果函数在线程中执行，它可能在任何位置被终止，然后在另一个线程中运行其他代码。

这个模型的一个缺点：当一个消息需要太长时间才能处理完毕时，Web 应用程序就无法处理和用户的交互（点击、滚动等）。为了缓解这个问题，浏览器一般会弹出一个“该脚本运行时间过长”的对话框。一个良好的习惯是缩减单个消息处理时间，并在可能的情况下将一个消息裁剪成多个消息。

添加消息

在浏览器中，每当一个事件发生并且有一个事件监听器绑定在该事件上时，一个消息就会被添加进消息队列。如果没有事件监听器，那么这个事件将会丢失。所以当一个带有点击事件处理器的元素被点击时，就会像其他事件一样产生一个类似的消息。

函数 setTimeout 接受两个参数：加入队列的消息和一个时间值（可选，默认为 0）。这个时间值代表了**消息实际被添加进消息队列的最小延迟时间**。如果消息队列中没有其他消息并且栈为空，在这段延迟时间过后，消息会被马上处理。但是，如果有其他消息，那么 setTimeout 消息必须等待其他消息被处理完毕。所以第二个参数仅仅表示最小延迟时间，而非确切的时间。

下边例子演示了这个概念（setTImeout 并不会在计时器到期之后立即执行）

```js
const s = new Date().getSeconds();

setTimeout(function () {
  // 输出 2，表示回调函数并没有在500毫秒后立即执行
  console.log('Ran after ' + (new Date().getSeconds() - s) + ' seconds');
}, 500);

while (true) {
  if (new Date().getSeconds() - s >= 2) {
    console.log('Good, looped for 2 seconds');
    break;
  }
}
```

零延迟

零延迟并不意味着回调会立即执行，以 0 为第二个参数调用 setTimeout 并不表示在 0 毫秒后就立即调用回调函数。

其等待时间取决于队列里待处理的消息数。

基本上，setTimeout 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经超出了由第二参数所指定的时间。

```js
(function () {
  console.log('这是开始');

  setTimeout(function cb() {
    console.log('这是来自第一个回调的消息');
  });

  console.log('这是一条消息');

  setTimeout(function cb1() {
    console.log('这是来自第二个回调的消息');
  }, 0);

  console.log('这是结束');
})();

// "这是开始"
// "这是一条消息"
// "这是结束"
// "这是来自第一个回调的消息"
// "这是来自第二个回调的消息"
```

多个运行时互相通信

一个 web worker 和一个跨源的 iframe 都有自己的栈、堆和队列。两个不同的运行时只能通过 postMessage 方法进行通信。如果另一个运行时侦听 message 事件，那么此方法会向该运行时添加消息。

## 永不阻塞

JavaScript 的事件循环模型与许多其他语言不同的一个有趣的特性是，它永不阻塞。处理 I/O 通常通过事件和回调来执行，所以一个应用正等待 IndexedDB 查询返回或者一个 XHR 请求返回时，他仍然可以处理其他事情，比如用户输入。

由于历史原因有一些例外，如 alert 或者同步 XHR，但应尽量避免使用它们。

## 事件循环过程

事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，关键的几步如下：

1. 执行一个宏任务（栈中没有就从事件队列中获取）。
2. 执行过程中遇到微任务则将其添加到微任务队列。
3. 宏任务执行完毕后，检查是否存在微任务，如果有则执行至微任务队列为空。
4. 微任务队列执行完后，开始检查渲染，然后 GUI 线程接管渲染。
5. 渲染完毕后，JS 线程再接管，开始下一个宏任务（从事件队列中获取）。

同步任务都在主线程上执行，形成一个执行栈。一旦执行栈中的所有同步任务执行完毕（此时 JS 引擎空闲），那么开始读取任务队列（分为**宏任务**队列和**微任务队**列），将可执行的异步任务添加到执行栈中。

宏任务（tasks，也就是任务）和微任务（microtasks）

一个**任务**就是由执行诸如从头执行一段程序、执行一个事件回调或一个 timeout/interval 被触发之类的标准机制而被调度的任务 JavaScript 代码。这些都在**任务队列**(task queue)上被调度。
在以下时机，任务会被添加到任务队列：

1. 一段新程序或子程序被直接执行时（如从控制台或者\<script\>元素中运行代码）
2. 触发了一个事件，将其回调函数添加到任务队列时
3. 执行一个由 setTimeout 或 setInterval 创建的 timeout 或 interval，以致相应的回调函数被添加到任务队列时
4. setImmediate（Node.js）
5. I/O
6. postMessage

注意 ⚠️：在 node 中，setTimeout(callback, 0)方法回调和 setImmediate(callback)方法回调执行顺序是不确定的。

一个**微任务**就是一个简短的函数，当创建该函数的函数执行之后，并且只有当 JavaScript 调用栈为空，而且控制权尚未返还给被**user agent**用来驱动脚本执行环境的事件循环之前，该微任务才会被执行。
使用微任务队列的有：

1. promise.then
2. MutationObserver（浏览器环境）
3. process.nextTick（Node.js 环境）
4. queueMicrotask 方法可以标准的管理使用微任务。

注意 ⚠️：在 node 中，queueMicrotask()方法的任务队列在 process.nextTick()方法的任务队列后执行。虽然都是微任务。

任务队列和微任务队列的区别：

- 当执行来自任务队列的任务时，在每一次新的事件循环开始迭代的时候运行时都会执行队列中的每一个任务。在每次迭代开始之后加入到队列中的任务需要在下一次迭代开始之后才会被执行。
- 每次当一个任务退出执行并且执行上下文为空的时候，微任务队列中的每一个任务会被执行。不同的是它会等到微任务队列为空时才会停止执行（即使中途有新微任务加入）。换句话说，微任务可以添加新的微任务到微任务队列中，并在下一个任务开始执行之前且当前事件循环执行结束之前执行完所有微任务。
- 宏任务由宿主发起（浏览器、 Node），微任务是 JS（JS 引擎）自身发起。
